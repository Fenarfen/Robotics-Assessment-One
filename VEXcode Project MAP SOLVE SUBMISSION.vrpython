{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\nfrom collections import deque\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\n# ------------------------------------------\n# \n# \tProject:      VEXcode Project\n#\tAuthor:       VEX\n#\tCreated:\n#\tDescription:  VEXcode VR Python Project\n# \n# ------------------------------------------\n\n# Add project code in \"main\"\ndef main():\n    brain.clear()\n    maze = Maze(8)\n    robot = Robot(maze)\n    robot.explore_maze()\n\n# Maze is to hold the point objects in a structure similar to the maze's simulated state and extra information\nclass Maze:\n    def __init__(self, size):\n        self.size = size\n        self.grid = [[Point(x, y) for y in range(size)] for x in range(size)]\n        self.finish_position = None\n        self.start_position = self.grid[4][0]\n        self.fastest_path = None\n        self.fastest_path_points = None\n\n    # Takes the maze object's grid and prints out an ascii representation with the fastest path also marked\n    def print_maze(self):\n        space = ' '\n        wall = '#'\n        start = 'S'\n        finish = 'F'\n        fastest_path = '*'\n        \n        ascii_size = self.size * 2 + 1 # scales the size to allow for walls\n        \n        ascii = [[wall for _ in range(ascii_size)] for _ in range(ascii_size)]\n        \n        for row in self.grid:\n            for cell in row:\n                x = cell.x * 2 + 1\n                y = (self.size - 1 - cell.y) * 2 + 1 # Invert y to match grid coordinates\n                \n                special = None\n                if cell.x == self.start_position.x and cell.y == self.start_position.y:\n                    special = \"S\"\n                elif cell.x == self.finish_position.x and cell.y == self.finish_position.y:\n                    special = \"F\"\n                else:\n                    found = False\n                    for point in self.fastest_path_points:\n                        if cell.x == point.x and cell.y == point.y:\n                            found = True\n\n                    if found:\n                        special = fastest_path\n                    else:\n                        special = space\n                \n\n                ascii[y][x] = special\n                    \n                if \"NORTH\" in cell.walls: # Wall present\n                    ascii[y-1][x] = wall\n                else: # No wall present\n                    ascii[y-1][x] = space\n                    \n                if \"EAST\" in cell.walls: # Wall present\n                    ascii[y][x+1] = wall\n                else: # No wall present\n                    ascii[y][x+1] = space\n                    \n                if \"SOUTH\" in cell.walls: # Wall present\n                    ascii[y+1][x] = wall\n                else: # No wall present\n                    ascii[y+1][x] = space\n                    \n                if \"WEST\" in cell.walls: # Wall present\n                    ascii[y][x-1] = wall\n                else: # No wall present\n                    ascii[y][x-1] = space\n\n        for row in ascii:\n            output = \"\"\n            for char in row:\n                output += char\n            brain.print(output)\n            brain.new_line()\n\n    # Calls the point's explore function and prints out the total percent of cells which have been mapped\n    def explore_point(self, point):\n        point.explore()\n\n        total_explored = 0\n\n        for i in self.grid:\n            for ii in i:\n                if ii.explored:\n                    total_explored += 1\n\n        total_size = self.size * self.size\n\n        percent_mapped = total_explored / total_size * 100\n        brain.print(f\"Maze has been {percent_mapped}% mapped\")\n        brain.new_line()\n\n    # Takes current point and the direction and returns the point in the grid in that direction\n    def get_relative_position(self, current_point, direction):\n        x, y = current_point.x, current_point.y\n\n        if direction == \"NORTH\":\n            y += 1\n        elif direction == \"SOUTH\":\n            y -= 1\n        elif direction == \"EAST\":\n            x += 1\n        elif direction == \"WEST\":\n            x -= 1\n        else:\n            brain.print(f\"Invalid direction: {direction}\")\n\n        if 0 <= x < len(self.grid) and 0 <= y < len(self.grid[0]):\n            return self.grid[x][y]\n        else:\n            return None\n\n# Handles the \"thinking\" of the robot and the movement\nclass Robot:\n    def __init__(self, maze):\n        self.maze = maze\n        self.current_point = maze.grid[4][0]\n        self.stack = []\n\n    # Aims to map the maze in a depth first search manner, return to the starting point, \n    # figure out the fastest path in a breadth first search manner to the end and then traverse that path\n\n    # DFS was chosen as the mapping algorithm as it will have as little traversal time as possible as the robot\n    # exhausts the path in front of it before backtracking\n\n    # BFS was chosen to calculate the fastest path due to is guarenteeing the shortest path from the origin to the destination,\n    # this is because all paths it's exploring are the same length, so the first one to reach the destination must the shortest path.\n    # While this will result in the shortest path, if you factor in turns it's possible that another path with less turns would take\n    # less time once you factor in time spent turning rather than moving.\n    def explore_maze(self):\n        brain.print(\"Starting to explore maze\")\n        brain.new_line()\n\n        self.maze.explore_point(self.current_point)\n\n        # The stack represents the paths explored and the direction taken\n        # when an unexplored adjacent point is found it is added to the stack and the robot moves to that position\n        # if a dead end is found then pop the last entry \n        self.stack = [(self.current_point, None)]\n\n        while self.stack:\n            # for debugging\n            # for index, (point, direction) in enumerate(self.stack):\n            #    brain.print(f\"Stack[{index}]: Point({point.x}, {point.y}), Direction: {direction}\")\n            #    brain.new_line()\n            \n            if down_eye.detect(RED):\n                self.maze.finish_position = self.current_point\n                brain.print(f\"Found finish point at x:{self.maze.finish_position.x} y:{self.maze.finish_position.y}\")\n                brain.new_line()\n\n            self.current_point, direction = self.stack[-1]\n            adjacent_point, next_direction = self.get_unexplored_adjacent(self.current_point)\n\n            if adjacent_point: # There are unexplored adjacent cells to go to\n                self.move(adjacent_point, [next_direction])\n                #brain.print(f\"Moved {next_direction} to x:{adjacent_point.x} y:{adjacent_point.y}\")\n                #brain.new_line()\n                self.current_point = adjacent_point\n                self.stack.append((self.current_point, next_direction))\n                self.maze.explore_point(self.current_point)\n            else: # Either a dead end or  break from the while loop as the entire maze is mapped\n                previous_point, previous_direction = self.stack.pop()\n                if previous_point: # if there is a previous point on the stack, go to the previous point on the stack\n                    if previous_direction != None:\n                        opposite_previous_direction = self.get_opposite_direction(previous_direction)\n                        self.move(previous_point, [opposite_previous_direction])\n                        #brain.print(f\"Backtracked {opposite_previous_direction} to x:{previous_point.x} y:{previous_point.y}\")\n                        #brain.new_line()\n                        self.current_point = previous_point\n                    else:\n                        break\n                else:\n                    raise ValueError(\"Error on finding previous point\")\n\n        while len(self.stack) > 1: # Entire maze is mapped so retake each step on the stack back to the start\n            previous_point, previous_direction = self.stack.pop()\n            opposite_previous_direction = self.get_opposite_direction(previous_direction)\n            self.move(previous_point, [opposite_previous_direction])\n            #brain.print(f\"Backtracked {opposite_previous_direction} to x:{previous_point.x} y:{previous_point.y}\")\n            #brain.new_line()\n            self.current_point = previous_point\n\n        brain.print(\"Returned to start\")\n        brain.new_line()\n\n        solver = Solver(self.maze)\n\n        path, points = solver.solve_shortest_path()\n        self.maze.fastest_path = path\n        self.maze.fastest_path_points = points\n\n        self.maze.print_maze()\n\n        pen.set_pen_color(RED)\n        pen.move(DOWN)\n        self.move(self.maze.finish_position, path)\n\n        brain.print(\"Maze solver finished\")\n        brain.new_line()\n       \n    # Take in the current point and return the first direction in directions\n    # which is unexplored (via print.explored), does not have a wall between the \n    # points, and is not going out of bounds (the open walls for the start and finish points)\n    def get_unexplored_adjacent(self, point):\n        directions = [\"NORTH\", \"SOUTH\", \"EAST\", \"WEST\"]\n        for direction in directions:\n            if direction in point.walls:\n                continue\n                \n            adjacent = self.maze.get_relative_position(point, direction)\n            if adjacent is not None:\n                oob = adjacent.x < 0 or adjacent.x > 7 or adjacent.y < 0 or adjacent.y > 7\n            else:\n                oob = True\n            if adjacent and not adjacent.explored and not oob:\n                return adjacent, direction\n        return None, None\n\n    def get_opposite_direction(self, direction):\n        if direction == \"NORTH\":\n            return \"SOUTH\"\n        elif direction == \"EAST\":\n            return \"WEST\"\n        elif direction == \"SOUTH\":\n            return \"NORTH\"\n        elif direction == \"WEST\":\n            return \"EAST\"\n        else:\n            return f\"error: direction unknown {direction}\"\n\n    # Takes in the target of the move and the list of directions needed to get there\n    def move(self, point, directions):\n        for direction in directions:\n            #brain.print(f\"Moving to x={point.x} y={point.y} facing {direction}\")\n            #brain.new_line()\n\n            heading = None\n\n            if direction == \"NORTH\":\n                heading = 0\n            elif direction == \"EAST\":\n                heading = 90\n            elif direction == \"SOUTH\":\n                heading = 180\n            elif direction == \"WEST\":\n                heading = 270\n            else:\n                raise ValueError(f\"Invalid direction - {direction}\")\n\n            drivetrain.turn_to_heading(heading, DEGREES)\n            drivetrain.drive_for(FORWARD, 250, MM)\n\n            # If any bumper is pressed then throw an error as something has gone wrong\n            if left_bumper.pressed() or right_bumper.pressed():\n                raise ValueError(\"Error: collision with wall detected\")\n\n            self.current_point = self.maze.get_relative_position(point, direction)\n\n# This class handles solving the fastest path through the maze using breadth first search\nclass Solver:\n    def __init__(self, maze):\n        self.maze = maze\n\n    # Solve the maze using Breadth First Search\n    def solve_shortest_path(self):\n        start = self.maze.start_position\n        end = self.maze.finish_position\n\n        if start is None or end is None:\n            raise ValueError(\"Start or finish position is not set.\")\n\n        queue = deque([(start, [], [])])  # (current_point, path_taken)\n        visited = set()\n\n        while queue:\n            current, path, points = queue.popleft()\n\n            if current in visited:\n                continue\n\n            visited.add(current)\n\n            # If we reach the final position, return the directions to get there and the points in that path\n            if current == end:\n                return path, points + [current]\n\n            # Get unvisited adjacent points with their movement directions\n            for neighbor, direction in self.get_adjacent_points(current):\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [direction], points + [current]))  # Extend the path\n\n        return None  # No path found\n\n    # Returns all points in the directions from the point given in the directions array,\n    # where there are no walls in between those points or the point is not out of bounds\n    def get_adjacent_points(self, point):\n        directions = [\"NORTH\", \"SOUTH\", \"EAST\", \"WEST\"]\n        adjacents = []\n\n        for direction in directions:\n            if direction in point.walls:\n                continue\n                \n            adjacent = self.maze.get_relative_position(point, direction)\n            if adjacent is not None:\n                oob = adjacent.x < 0 or adjacent.x > 7 or adjacent.y < 0 or adjacent.y > 7\n            else:\n                oob = True\n            if adjacent and not oob:\n                adjacents.append((adjacent, direction))\n\n        return adjacents\n\n# The Point class represents a 250mm x 250mm square of the maze and holds the position of that square\nclass Point:\n    def __init__(self, x = None, y = None):\n        self.x = x\n        self.y = y\n        self.explored = False\n        self.walls = []\n        self.known = []\n        self.special = None\n\n    # scans whether there are walls in each 4 directions by spinning around and using the front eye's get_distance method\n    def explore(self):\n        for i in range(4):\n            currentRotation = drivetrain.heading(DEGREES)\n\n            if(front_distance.get_distance(MM) < 200):\n                if currentRotation == 0:\n                    self.walls.append(\"NORTH\")\n                elif currentRotation == 90:\n                    self.walls.append(\"EAST\")\n                elif currentRotation == 180:\n                    self.walls.append(\"SOUTH\")\n                elif currentRotation == 270:\n                    self.walls.append(\"WEST\")\n                else:\n                    brain.print(f\"Heading is not correct - {drivetrain.rotation(DEGREES)}\")\n                    brain.new_line()\n\n            drivetrain.turn_for(RIGHT, 90, DEGREES)\n\n        self.explored = True\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def __repr__(self):\n        return f\"Point(x={self.x}, y={self.y}, explored={self.explored})\"\n\n# ************************************\n# Potential improvements\n\n# Exploring points could be improved by only scanning in directions which aren't known about as when scanning a wall,\n# we also know that there is a space on the other side of a wall, or when looking down a corridor we know that there are distance/250mm cells\n# without walls in that direction\n# ************************************\n\n# VR threads — Do not delete\nvr_thread(main)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.0.8","minVersion":"3.0.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"playground":"DynamicWallMaze","robotModel":"vr"}